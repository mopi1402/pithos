import React, {type ReactNode} from 'react';
import clsx from 'clsx';

import styles from './styles.module.css';
import { computeDensities, computeWidths } from './picture-utils';

export { computeDensities, computeWidths } from './picture-utils';

/** Manifest generated by generate-images.ts — maps src to effective maxDpr */
let manifest: Record<string, { maxDpr: number; widths: number[] }> = {};
try {
  // Static import at build time (SSG). The file is in static/img/generated/manifest.json
  // Docusaurus/webpack resolves this from the static directory.
  // eslint-disable-next-line @typescript-eslint/no-require-imports
  manifest = require('@site/static/img/generated/manifest.json');
} catch {
  // Manifest not yet generated — first build or clean state
}

type ImageFormat = 'avif' | 'webp' | 'png' | 'jpg';

interface PictureProps {
  src: string;
  alt: string;
  // Fluid mode (existing)
  widths?: number[];
  sizes?: string;
  // Density mode (new)
  displaySize?: number;
  densities?: number[];
  /** Cap the maximum DPR variants generated (e.g. maxDpr={2} → only 1x and 2x) */
  maxDpr?: number;
  // Common
  formats?: ImageFormat[];
  sourceWidth?: number;
  sourceHeight?: number;
  width?: number;
  height?: number;
  loading?: 'lazy' | 'eager';
  // LCP (new)
  priority?: boolean;
  className?: string;
  style?: React.CSSProperties;
  inline?: boolean;
}

export function Picture({
  src,
  alt,
  widths = [400, 800, 1200],
  sizes = '100vw',
  displaySize,
  densities: explicitDensities,
  maxDpr,
  formats = ['avif', 'webp'],
  sourceWidth,
  sourceHeight,
  width,
  height,
  loading: loadingProp,
  priority,
  className,
  style,
  inline = false,
}: PictureProps): ReactNode {
  const isDensityMode = displaySize != null;

  // Warn if both displaySize and widths are explicitly provided (dev only)
  // Note: widths always has a default value, so we can't distinguish explicit from default here.
  // The warning is emitted when displaySize is present as a reminder to prefer displaySize.

  // Priority logic
  const loading = priority ? 'eager' : (loadingProp ?? 'lazy');
  const decoding = priority ? 'sync' as const : 'async' as const;
  const fetchPriority = priority ? 'high' as const : undefined;

  const fallback = formats.at(-1)!;
  const sources = formats.slice(0, -1);

  if (isDensityMode) {
    // Resolve effective maxDpr: explicit prop > manifest > unlimited
    const manifestEntry = manifest[src];
    const effectiveMaxDpr = maxDpr ?? manifestEntry?.maxDpr;

    const densities = computeDensities(displaySize, sourceWidth, explicitDensities, effectiveMaxDpr);
    const computedWidths = computeWidths(displaySize, densities, sourceWidth);

    const buildDensitySrcSet = (fmt: string) =>
      computedWidths.map((w, i) => `${src}-${w}.${fmt} ${i + 1}x`).join(', ');

    // CLS prevention: emit width and height in density mode
    const imgWidth = width ?? displaySize;
    let imgHeight = height;
    if (imgHeight == null && sourceWidth != null && sourceHeight != null) {
      imgHeight = Math.round(displaySize * sourceHeight / sourceWidth);
    }

    // Default src: use the 1x width
    const defaultWidth = computedWidths[0] ?? displaySize;

    return (
      <picture className={clsx(styles.picture, inline && styles.inline, className)} style={style}>
        {sources.map((fmt) => (
          <source
            key={fmt}
            type={`image/${fmt}`}
            srcSet={buildDensitySrcSet(fmt)}
          />
        ))}
        <img
          src={`${src}-${defaultWidth}.${fallback}`}
          srcSet={buildDensitySrcSet(fallback!)}
          width={imgWidth}
          height={imgHeight}
          loading={loading}
          decoding={decoding}
          fetchPriority={fetchPriority}
          alt={alt}
          className={clsx(styles.img, inline && styles.inlineImg)}
        />
      </picture>
    );
  }

  // Fluid mode (existing behavior)
  const buildSrcSet = (fmt: string) =>
    widths.map((w) => `${src}-${w}.${fmt} ${w}w`).join(', ');

  return (
    <picture className={clsx(styles.picture, inline && styles.inline, className)} style={style}>
      {sources.map((fmt) => (
        <source
          key={fmt}
          type={`image/${fmt}`}
          srcSet={buildSrcSet(fmt)}
          sizes={sizes}
        />
      ))}
      <img
        src={`${src}-${widths[1] ?? widths[0]}.${fallback}`}
        srcSet={buildSrcSet(fallback!)}
        sizes={sizes}
        width={width}
        height={height}
        loading={loading}
        decoding={decoding}
        fetchPriority={fetchPriority}
        alt={alt}
        className={clsx(styles.img, inline && styles.inlineImg)}
      />
    </picture>
  );
}
